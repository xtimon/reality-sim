# RealitySim

Библиотека для исследования emergent-ных свойств реальности через квантовую механику.

## Описание

RealitySim - это Python-библиотека, которая моделирует то, как фундаментальные законы физики могут возникать (emerge) из простых квантовых правил. Проект исследует:

- **Квантовая ткань реальности**: Моделирование квантовых систем с запутанностью
- **Emergent законы**: Как физические законы возникают из простых правил
- **Влияние наблюдателя**: Моделирование декогеренции в зависимости от свойств наблюдателя

## Установка

```bash
pip install -e .
```

Или установите зависимости напрямую:

```bash
pip install numpy scipy matplotlib
```

## Быстрый старт

```python
from reality_sim import QuantumFabric, EmergentLaws, HUMAN_OBSERVER

# Создание квантовой системы (автоматически использует GPU если доступен)
system = QuantumFabric(num_qubits=3)
print(system.get_state_info())

# Создание запутанности
system.apply_entanglement_operator([(0, 1), (1, 2)])
print(system.get_state_info())

# Измерение кубита
result = system.measure(0)
print(f"Измерение кубита 0: {result}")

# Симуляция рождения частиц
particles = EmergentLaws.simulate_particle_creation(
    vacuum_energy=0.1, 
    time_steps=50
)
print(f"Создано {len(particles)} пар частица-античастица")

# Влияние наблюдателя
coherence = HUMAN_OBSERVER.observe_system(1.0, observation_time=1.0)
print(f"Сохраненная когерентность: {coherence:.2e}")

# Использование GPU (если доступен)
system_gpu = QuantumFabric(num_qubits=20, use_gpu=True)
print(f"Система на GPU: {system_gpu.get_state_info()}")
```

## Структура проекта

```
reality_sim/
├── core/
│   └── quantum_fabric.py    # Квантовая система и запутанность
├── emergence/
│   └── laws.py              # Emergent физические законы
└── observers/
    └── observer.py          # Модель наблюдателя и декогеренция
```

## Основные компоненты

### QuantumFabric

Класс для работы с квантовыми системами:

- `__init__(num_qubits, entanglement_strength, use_gpu=None)`: Создание системы из n кубитов
  - `use_gpu=None`: Автоопределение (использует GPU если доступен для систем ≥15 кубитов)
  - `use_gpu=True`: Принудительное использование GPU
  - `use_gpu=False`: Принудительное использование CPU
- `apply_entanglement_operator(qubit_pairs)`: Создание запутанности между кубитами
- `measure(qubit_index)`: Измерение кубита с коллапсом состояния
- `get_state_info()`: Информация о текущем состоянии
- **GPU поддержка**: Автоматически использует GPU для больших систем (если CuPy установлен)

### EmergentLaws

Статические методы для моделирования emergent явлений:

- `simulate_particle_creation()`: Рождение пар частица-античастица
- `landauer_principle()`: Минимальная энергия стирания информации
- `estimate_metric_from_entanglement()`: Оценка метрики пространства-времени

### Observer

Модель наблюдателя с декогеренцией:

- `__init__(mass, temperature, complexity)`: Создание наблюдателя
- `observe_system(quantum_system, observation_time)`: Взаимодействие с системой
- Предустановленные наблюдатели: `HUMAN_OBSERVER`, `LIGO_OBSERVER`, `ELECTRON_OBSERVER`

## Примеры использования

См. файл `quantum_emergence.py` для полных примеров:

```bash
python quantum_emergence.py
```

После выполнения симуляции можно проанализировать результаты:

```bash
python analyze_simulation.py
```

Это создаст визуализации и отчеты в папке `analysis_output/`.

## Результаты анализа

### Статистика последней симуляции

На основе выполненной симуляции получены следующие результаты:

- **Квантовые системы:** 82 системы (от 2 до 10 кубитов)
- **Точки данных декогеренции:** 13,000 точек для 13 различных наблюдателей
- **Симуляции рождения частиц:** 750 симуляций, создано 2,480 пар частиц
- **Параметрические развертки:** 5 различных типов анализа

### Ключевые выводы

1. **Квантовая запутанность:**
   - Средняя энтропия запутанности: 0.85 (медиана: 0.94)
   - Все системы сохраняют полную когерентность (1.000)
   - Энтропия корректно зависит от силы операторов и количества кубитов

2. **Декогеренция:**
   - Сила декогеренции варьируется на много порядков в зависимости от параметров наблюдателя
   - Экспоненциальный спад когерентности соответствует теоретическим ожиданиям
   - Различные наблюдатели демонстрируют существенно разное влияние на системы

3. **Рождение частиц:**
   - Количество пар частиц увеличивается с ростом энергии вакуума
   - Статистика времени создания соответствует физическим ожиданиям

4. **Принцип Ландауэра:**
   - Результаты соответствуют теоретической зависимости E = k_B * T * ln(2) * bits
   - Масштабирование корректно для широкого диапазона параметров (1-100M бит, 1-1000K)

### Визуализации

Все графики сохранены в папке `analysis_output/`:

- `quantum_systems_analysis.png` - Распределение запутанности и когерентности
- `decoherence_analysis.png` - Декогеренция во времени для различных наблюдателей
- `particle_creation_analysis.png` - Зависимость рождения частиц от энергии вакуума
- `entanglement_strength.png` - Зависимость энтропии от силы запутанности
- `landauer_temperature.png` - Принцип Ландауэра: зависимость от температуры
- `landauer_bits.png` - Принцип Ландауэра: зависимость от количества бит

### Подробный отчет

Полный отчет с детальным анализом доступен в файле:
- `analysis_output/detailed_report.md` - Подробный отчет с выводами и рекомендациями

## Требования

- Python >= 3.9
- numpy >= 1.21.0
- scipy >= 1.7.0
- matplotlib >= 3.5.0 (опционально, для визуализации)

### GPU поддержка (опционально)

Для ускорения вычислений на GPU (NVIDIA):

```bash
# Установка CuPy для CUDA 12.x
pip install cupy-cuda12x

# Или установите с extras
pip install -e .[gpu]
```

См. [GPU_SETUP.md](GPU_SETUP.md) для подробной инструкции по настройке GPU.

## Физические основы

### Квантовая запутанность

Система использует CNOT-подобные операторы для создания запутанности между кубитами. Операторы сохраняют унитарность для корректной квантовой эволюции.

### Декогеренция

Сила декогеренции наблюдателя вычисляется по формуле:
```
Γ = ln(1 + |m * c / T|)
```
где:
- m - масса наблюдателя
- c - сложность наблюдателя
- T - температура

### Принцип Ландауэра

Минимальная энергия для стирания информации:
```
E_min = k_B * T * ln(2) * bits
```

## Разработка

Проект использует:
- Type hints для лучшей читаемости кода
- Валидацию входных данных
- Нормализацию квантовых состояний
- Проверку унитарности операторов

## Лицензия

MIT License

## Автор

Timur Isanov

